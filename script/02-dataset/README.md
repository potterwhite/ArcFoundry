# 语音识别模型（流式Zipformer）RKNN int8量化校准数据集生成脚本演进史

本文档详细记录了为 `sherpa-onnx` 流式 Zipformer 模型生成 `int8` RKNN 量化校准数据集所经历的几个关键脚本版本的迭代过程。每个脚本都代表了我们对量化原理理解的一次深化，最终版本 (`08_...`) 是当前推荐使用的最佳实践。

## 文件列表

- `05_generate_calibration_dataset_streaming.py`
- `06_generate_calibration_dataset_snapshot.py`
- `07_generate_calibration_dataset_hybrid.py`
- `08_generate_calibration_dataset_final.py` **(当前推荐版本)**

---

### **版本演进详情**

#### 📜 `05_generate_calibration_dataset_streaming.py`

*   **核心思想：** **完全模拟** `sherpa-onnx` 的流式推理过程。通过滑动窗口处理整个音频，并使用 `onnxruntime` 进行前向推理，以生成**真实的、非零的**历史状态（state）张量。
*   **实现方式：**
    1.  对每个音频，以固定的步长（`chunk_shift`）进行滑动窗口。
    2.  在**每一个时间步**，将当前的特征块 (`x`) 和**上一步推理得到的 35 个状态**打包在一起。
    3.  将这**全部 36 个**张量保存为独立的 `.npy` 文件。
    4.  `dataset.txt` 的每一行都包含这 36 个 `.npy` 文件的路径。
*   **遇到的问题（致命缺陷）：**
    *   **磁盘空间爆炸：** 由于流式模型巨大的状态张量在每个时间步都被完整地保存了一遍，导致 500 个音频文件生成了 **46GB** 的校准数据。
    *   **I/O 性能灾难：** `rknn-toolkit2` 在量化时需要读取海量的小文件，导致硬盘/网络 I/O 成为极端瓶颈，量化过程极其缓慢（预计需要几十个小时）。
*   **结论：** 理论上最严谨，但工程上完全不可行。**此版本已被废弃。**

---

#### 📜 `06_generate_calibration_dataset_snapshot.py`

*   **核心思想：** 为了解决磁盘空间和 I/O 问题，进行**极端简化**。假设量化过程只需要关心特征输入 (`x`) 的分布，而状态可以忽略。
*   **实现方式：**
    1.  对每个音频，只提取几个有代表性的特征块（“快照”），如开头、中间、结尾。
    2.  **只保存**这些特征块的 `.npy` 文件。
    3.  `dataset.txt` 的每一行**只有一个**特征块 `.npy` 文件的路径。
    4.  **错误地假设** `rknn-toolkit2` 会自动为模型缺失的 35 个状态输入补零。
*   **遇到的问题（致命缺陷）：**
    *   **接口不匹配：** `rknn-toolkit2` 的 `build` 接口要求 `dataset.txt` 中每一行提供的数据数量必须与模型的输入数量**严格相等**。由于模型需要 36 个输入，而我们只提供了 1 个，导致工具直接报错退出。
*   **结论：** 方向正确（轻量化），但实现方式与工具链要求不符。**此版本已被废弃。**

---

#### 📜 `07_generate_calibration_dataset_hybrid.py`

*   **核心思想：** 结合 `05` 和 `06` 版本的优点，既满足 `rknn-toolkit2` 的接口要求，又保持轻量化。
*   **实现方式：**
    1.  **一次性**创建 35 个包含全零数据的“状态模板” `.npy` 文件。
    2.  像 `06` 脚本一样，从每个音频中提取少量特征“快照”，并保存为 `.npy` 文件。
    3.  构建 `dataset.txt` 时，每一行的内容是：**1 个**特征快照的路径 + **35 个**状态模板文件的路径。
*   **解决了什么问题：**
    *   完美解决了磁盘空间和 I/O 性能问题，数据集总大小仅为几十MB。
    *   满足了 `rknn-toolkit2` 每一行需要 36 个输入的接口要求。
*   **暴露的新问题：**
    *   用这个数据集量化出的模型虽然能完整运行，但**精度严重不足**。这暴露出我们的 Python 特征提取逻辑与 `sherpa-onnx` C++ 运行时的实现存在**根本性差异**。
*   **结论：** 这是一个在**接口层面**正确的版本，为我们最终定位到特征提取问题铺平了道路。

---

#### ✅ `08_generate_calibration_dataset_final.py` (当前推荐版本)

*   **核心思想：** 在 `07` 版本的正确框架之上，**精确复现** `sherpa-onnx` C++ 端的音频波形预处理流程。
*   **实现方式：**
    1.  保留了 `07` 脚本的“快照+补零”的核心逻辑。
    2.  在特征提取函数中，根据对 `sherpa-onnx/csrc/features.h` 源码的分析，在 `librosa` 计算 Fbank **之前**，对音频波形 `waveform` 依次进行了以下关键预处理：
        *   **去直流偏置 (Remove DC Offset):** `waveform = waveform - np.mean(waveform)`
        *   **预加重 (Pre-emphasis):** `waveform = librosa.effects.preemphasis(waveform, coef=0.97)`
        *   (可选) **加噪 (Dithering)**
*   **解决了什么问题：**
    *   **特征一致性：** 确保了用于校准的特征数据，在数值分布上与模型在 C++ 真实运行时接收到的特征高度一致。
*   **结论：** 这是当前**最正确、最高效、最推荐**的校准数据生成脚本。它解决了我们之前遇到的所有问题，能够为 `rknn-toolkit2` 提供高质量的校准数据，是生成高精度 `int8` 模型的基础。



#### ✅ `09_generate_calibration_dataset.py` (当前推荐版本)

*   **核心思想：** **集大成者**。结合了我们所有经验教训，实现了理论正确性与工程可行性的完美统一。
*   **实现方式：**
    1.  **精确特征提取：** 使用了 `08` 版本中与 C++ 对齐的、包含完整预处理的特征提取流程。
    2.  **真实状态模拟：** 像 `05` 版本一样，使用 `onnxruntime` 完整模拟流式推理，以计算出每一步**真实的、非零的**历史状态。
    3.  **随机采样：** 为了解决 `05` 版本的磁盘爆炸问题，脚本不再保存**所有**时间步的数据。而是在内存中收集所有可能的（特征+真实状态）组合，然后从中**随机抽取**少量（例如 200 个）样本，最后才将这些抽出的样本完整地写入 `.npy` 文件。
*   **解决了什么问题：**
    *   **数据质量最高：** 校准数据同时包含了最精确的特征和最真实的历史状态。
    *   **资源占用合理：** 通过随机采样，将数据集大小和生成时间控制在完全可接受的范围内。
*   **结论：** 这是当前**最正确、最高效、最推荐**的校准数据生成脚本，是生成高精度 `int8` 模型的最终解决方案。
